#include <Arduino.h>

#include "slip.h"

#define END     0300
#define ESC     0333
#define ESC_END 0334
#define ESC_ESC 0335

#define SLIP_RX_SIZE 1024

static byte slip_rx_buffer[SLIP_RX_SIZE];
static unsigned head, tail;
//static unsigned end_count;


// Receive data from Serial if any is available.
// If there's a buffer overflow (shouldn't happen), overwrite the oldest data.
static void receive_slip_data()
{
	while (Serial.available()) {
		byte b = Serial.read();
		unsigned next_tail = (tail + 1) % SLIP_RX_SIZE;
		if (next_tail == head) {
			// Buffer is full. Drop the oldest data in the buffer.
			head = (head + 1) % SLIP_RX_SIZE;
			// If the oldest byte was an END byte, decrement the
			// END count.
			//if (slip_rx_buffer[next_tail] == END) --end_count;
		}

		slip_rx_buffer[tail] = b;
		tail = next_tail;
		//if (b == END) ++end_count;
	}
}

static byte recv_char()
{
	while (head == tail) {
		receive_slip_data();
	}
	byte b = slip_rx_buffer[head];
	head = (head + 1) % SLIP_RX_SIZE;

	//if (b == END) --end_count;
	return b;
}

static void send_char(byte c)
{
	Serial.write(c);
	receive_slip_data();
}

/*
 * recv_packet and send_packet are copied almost verbatim from RFC 1055
 * (https://tools.ietf.org/html/rfc1055)
 */

/* SEND_PACKET: sends a packet of length "len", starting at
 * location "p".
 */
void slip_send_packet(const void *vp, unsigned len)
{
	const byte *p = (const byte *)vp;

	/* send an initial END character to flush out any data that may
	 * have accumulated in the receiver due to line noise
	 */
	send_char(END);

	/* for each byte in the packet, send the appropriate character
	 * sequence
	 */
	while(len--) {
		switch(*p) {
			/* if it's the same code as an END character, we send a
			 * special two character code so as not to make the
			 * receiver think we sent an END
			 */
			case END:
				send_char(ESC);
				send_char(ESC_END);
				break;

				/* if it's the same code as an ESC character,
				 * we send a special two character code so as not
				 * to make the receiver think we sent an ESC
				 */
			case ESC:
				send_char(ESC);
				send_char(ESC_ESC);
				break;

				/* otherwise, we just send the character
				 */
			default:
				send_char(*p);
		}

		p++;
	}

	/* tell the receiver that we're done sending the packet
	 */
	send_char(END);
}
/* RECV_PACKET: receives a packet into the buffer located at "p".
 *      If more than len bytes are received, the packet will
 *      be truncated.
 *      Returns the number of bytes stored in the buffer.
 */
unsigned slip_recv_packet(byte *p, unsigned len)
{
	byte c;
	unsigned received = 0;

	/* sit in a loop reading bytes until we put together
	 * a whole packet.
	 * Make sure not to copy them into the packet if we
	 * run out of room.
	 */
	while(1) {
		/* get a character to process
		 */
		c = recv_char();

		/* handle bytestuffing if necessary
		 */
		switch(c) {

			/* if it's an END character then we're done with
			 * the packet
			 */
			case END:
				/* a minor optimization: if there is no
				 * data in the packet, ignore it. This is
				 * meant to avoid bothering IP with all
				 * the empty packets generated by the
				 * duplicate END characters which are in
				 * turn sent to try to detect line noise.
				 */
				if(received)
					return received;
				else
					break;

				/* if it's the same code as an ESC character, wait
				 * and get another character and then figure out
				 * what to store in the packet based on that.
				 */
			case ESC:
				c = recv_char();

				/* if "c" is not one of these two, then we
				 * have a protocol violation.  The best bet
				 * seems to be to leave the byte alone and
				 * just stuff it into the packet
				 */
				switch(c) {
					case ESC_END:
						c = END;
						break;
					case ESC_ESC:
						c = ESC;
						break;
				}

				/* here we fall into the default handler and let
				 * it store the character for us
				 */
			default:
				if(received < len)
					p[received++] = c;
		}
	}
}



